= 07-学习c语言
:doctype: article
:encoding: utf-8
:lang: zh-cn
:toc: left
:toc-title: 导航目录
:toclevels: 4
:sectnums:
:sectanchors:

:hardbreaks:
:experimental:
:icons: font

[preface]
想要看懂hotspot源码,逃不过,理解和学习c语言;

推荐阅读::
https://wangdoc.com/clang/index.html[阮一峰的c语言教程]
非常感谢阮一峰老师的教程!学习c语言变得轻松很多!
但是作为初学者,我们还需要进一步总结下!

== 简介

=== 历史

C 语言最初是作为 Unix 系统的开发工具而发明的;
C 语言是在B语言的基础上开发的;
目前,Unix 和 Linux 系统现在还是使用 C 语言开发;

=== C语言的版本

- K＆R C
- ANSI C（又称 C89 或 C90）
- C95
- C99 目前最流行的版本
- C11
- C17
- C2x 据说可能会在2023年通过,到时就会称为C23;

=== C语言的编译

C 语言是一种编译型语言,源码都是文本文件,本身无法执行;必须通过编译器,生成二进制的可执行文件,才能执行;
使用C语言需要GCC编译器;如同运行java需要jdk方可运行;

> GCC在不同平台的安装

- MINGW在Windows平台下的安装
https://blog.csdn.net/wxh0000mm/article/details/100666329[]

- 在Ubuntu中安装
[source,bash]
----
# 更新包列表
sudo apt update

# 执行安装,此安装包含gcc,g++,make
sudo apt install build-essential
----

- 在Centos下安装
[source,bash]
----
# 更新包列表
sudo yum update

# 执行安装,此安装包含gcc,g++,make
sudo yum -y install gcc gcc-c++ kernel-devel
----

使用 `gcc -v` 来验证是否安装成功!

> GCC相关指令的熟练使用

安装gcc完成后,需要熟练使用gcc指令

gcc常用指令汇总::
https://wangchujiang.com/linux-command/c/gcc.html[linux-command]

当然你也可以使用 gcc --help来查看命令

常用命令一览
[source,bash]
----
gcc -c testfun.c    #将testfun.c编译成testfun.o

# 编译多个文件,test为输出文件
gcc testfun.c test.c -o test
# 替换成此命令
gcc *.c -o test
----

gcc命令 会在之后make文件中继续使用!

== 基本使用

说道C入门,最主要是要熟练使用printf方法

====
[source,c]
----
#include <stdio.h> <1>

int main(void) { <2>
  printf("Hello World\n");
  printf("%s will learn c language\n", "you");
  return 0;
}
----
<1> #include 表示为头文件,不引入头文件 printf 无法使用!
<2> main方法为 代码主入口;
====

挑战: 使用入门代码,编译通过并输出Hello World!

printf 最主要包含占位符,输出文本里面可以使用多个占位符;

常用的占位符,是和数据类型相关的;
如字符 char 对应占位符 为 %c;
如指针 point 对应占位符 为 %p;

先将常用的占位符列出,请关注数据类型小节;
- `%a`：浮点数。
- `%A`：浮点数。
- `%c`：字符。
- `%d`：十进制整数。
- `%e`：使用科学计数法的浮点数，指数部分的`e`为小写。
- `%E`：使用科学计数法的浮点数，指数部分的`E`为大写。
- `%i`：整数，基本等同于`%d`。
- `%f`：小数（包含`float`类型和`double`类型）。
- `%g`：6个有效数字的浮点数。整数部分一旦超过6位，就会自动转为科学计数法，指数部分的`e`为小写。
- `%G`：等同于`%g`，唯一的区别是指数部分的`E`为大写。
- `%hd`：十进制 short int 类型。
- `%ho`：八进制 short int 类型。
- `%hx`：十六进制 short int 类型。
- `%hu`：unsigned short int 类型。
- `%ld`：十进制 long int 类型。
- `%lo`：八进制 long int 类型。
- `%lx`：十六进制 long int 类型。
- `%lu`：unsigned long int 类型。
- `%lld`：十进制 long long int 类型。
- `%llo`：八进制 long long int 类型。
- `%llx`：十六进制 long long int 类型。
- `%llu`：unsigned long long int 类型。
- `%Le`：科学计数法表示的 long double 类型浮点数。
- `%Lf`：long double 类型浮点数。
- `%n`：已输出的字符串数量。该占位符本身不输出，只将值存储在指定变量之中。
- `%o`：八进制整数。
- `%p`：指针。
- `%s`：字符串。
- `%u`：无符号整数（unsigned int）。
- `%x`：十六进制整数。
- `%zd`：`size_t`类型。
- `%%`：输出一个百分号。

变量 运算符 流程控制 与java保持一致;无需记忆!

== 基本数据类型

=== 字符,整数和浮点数


- 字符类型
char 单字节;

字符类型在不同计算机的默认范围是不一样的。一些系统默认为-128到127，另一些系统默认为0到255。
这两种范围正好都能覆盖0到127的 ASCII 字符范围。

[source,c]
----
char x = 'B';
char x = 66;
char x = '\102'; // 'B'的八进制
char x = '\x42'; // 'B'的十六进制
----

- 整数int
位数不定

不同计算机的int类型的大小是不一样的。比较常见的是使用4个字节（32位）存储一个int类型的值，但是2个字节（16位）或8个字节（64位）也有可能使用;

- signed，unsigned

整数 int,默认 为 signed int;
但是 char,默认值,由系统决定,signed char 和 unsigned char都有可能!

- 整数的子类型

整数都是默认有符号的;

[source,c]
----
short int a;
long int b;
long long int c;

// int 可不写
// 你也可以写无符号的短整数
unsigned short a;
----

整数的极限值,忽略;

- 整数的进制

====
[source,c]
----
int x = 100;
printf("dec = %d\n", x); // 100
printf("octal = %o\n", x); // 144
printf("hex = %x\n", x); // 64
printf("octal = %#o\n", x); // 0144 <1>
printf("hex = %#x\n", x); // 0x64 <1>
printf("hex = %#X\n", x); // 0X64
----
<1> 注释即为整数的其他进制写法
====

- 浮点数
float 占用4字节
double 占用8字节
long double,占用16字节

[source,c]
----
float c = 10.5;
double x = 123.456e+3; // 123.456 x 10^3
// 等同于
double x = 123.456e3;
----

- 布尔类型

C 语言原来并没有为布尔值单独设置一个类型，而是使用整数0表示伪，所有非零值表示真。
C99 标准添加了类型_Bool，表示布尔值。但是，这个类型其实只是整数类型的别名，还是使用0表示伪，1表示真;
[source,c]
----
int x = 1;
if (x) {
  printf("x is true!\n");
}

_Bool isNormal;

isNormal = 1;
if (isNormal)
  printf("Everything is OK.\n");
----

=== 可移植性

在头文件 `stdint.h` 中引入了精确宽度类型

- `int8_t`：8位有符号整数。
- `int16_t`：16位有符号整数。
- `int32_t`：32位有符号整数。
- `int64_t`：64位有符号整数。
- `uint8_t`：8位无符号整数。
- `uint16_t`：16位无符号整数。
- `uint32_t`：32位无符号整数。
- `uint64_t`：64位无符号整数。

其中 `uint8_t`,即为单字节整数;在hotspot源码中大量存在;

=== sizeof

====
[source,c]
----
// 参数为数据类型
size_t x = sizeof(int); <1>

// 参数为变量
int i;
sizeof(i);

// 参数为数值
sizeof(3.14);
----
<1> sizeof 可以直接计算类型占用的字节数;
而sizeof返回值size_t,本质上是 unsigned int;
====

== 指针

熟练以下内容,即大致掌握了指针的用法!

====
[source,c]
----
#include <stdio.h>
#include <stdint.h>

void intVariable(int intCopy);
void updateIntVariable(int *pInt);
void updateBroVariable(int *pInt);
void doublePoint(int *pInt);

int main() {

    printf("int size %d\n", sizeof(int));
    int paramInt = 1;
    printf("param address %p\n", &paramInt);
    intVariable(paramInt);

    return 0;
}

void intVariable(int intCopy) {
    int simpleInt = intCopy;
    printf("current variable init value %d\n", intCopy);

    printf("current variable address %p\n", &simpleInt);
    int *pInt = &simpleInt;
    updateIntVariable(pInt);
    printf("current variable value %d\n", simpleInt);

    updateBroVariable(pInt);
    doublePoint(pInt);
}

void updateIntVariable(int *pInt) {
    *pInt = *pInt + 1; <2>
    printf("current variable address %p\n", pInt);
}

void updateBroVariable(int *pInt) {
    int *pBroInt = pInt + 1; <3>
    *pBroInt = 3; <>
    printf("bro point address %p\n", pBroInt);
    printf("bro point real value %d\n", *pBroInt);
    printf("two point minus, result %d\n", pBroInt - pInt);
}

void doublePoint(int* pInt) {
    int **ppInt = &pInt; <4>
    int *pBroInt = pInt + 1;
    **ppInt = 4;
    *ppInt = pBroInt;

    printf("double point real value %d and address %p\n", **ppInt, *ppInt);
    printf("single point real value %d and address %p\n", *pInt, pInt);
}
----
<1> *号在变量声明处,代表声明了指针变量;
&simpleInt,代表取出simpleInt在内存中所在地址;
<2> *pInt = *pInt + 1; pInt原本是指针,而*号和指针变量在一起,此*号为运算符,意指从此地址取出实际存放的值;
<3> 2,3比较; int *pBroInt = pint + 1, 这里是对指针进行加法操作;即地址进行加法操作;得到当然是一个新的地址;
而此地址的值,是和sizeof(int)相关,请自行体会;
<4> int **ppInt = &pInt; &pInt此处是指pInt的地址;即指针的地址,&在此处为运算符;
====

熟练掌握 *号在当做指针声明 和 *,& 号当做运算符时的写法;

== 函数

=== 函数的声明和实现拆分

在学习指针时,我们已经使用了函数;但是我们基本上都会在多文件中使用函数;
我们改造下上面代码涉及的函数;将函数的声明和实现拆分,方便我们代码的复用;

- 头文件-函数的声明

.point_tranning.h
[source,c]
----
void intVariable(int intCopy);

void updateIntVariable(int *pInt);

void updateBroVariable(int *pInt);

void doublePoint(int *pInt);
----

- c文件-函数的实现

====
[source,c]
----
#include <stdio.h>
#include "point_tranning.h" <1>

// 函数的实现已经在指针的代码中说明,请自行copy
----
<1> 上面代码中，#include "point_tranning.h"表示加入头文件point_tranning.h;
这个文件没有放在尖括号里面，表示它是用户提供的;
它没有写路径，就表示与当前源码文件在同一个目录。
====

那我们的主文件只需要加入此头文件,就可以简化了;

=== 将函数本身当做指针处理

[source,c]
----
void functionHandler(void (*method)(int), int param);

void functionHandler(void (*method)(int), int param) {
method(param);
}
----

void (*method)(int) 意为着将入参为int,返回值为void的函数,当做参数;

比较特殊的是，C 语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址;
[source,c]
----
(*method)(10);
(&method)(10);
method(10);

----
`(*method)(10)`, `(&method)(10)` 等同于 `method(10)`;

=== 可变参数

[sourec,c]
----
#include <stdarg.h>

double average(int i, ...) {
    double total = 0;
    va_list ap;
    va_start(ap, i);
    for (int j = 1; j <= i; ++j) {
        total += va_arg(ap, double);
    }
    va_end(ap);
    return total / i;
}
----

头文件`stdarg.h`定义了一些宏，可以操作可变参数。

- `va_list`：一个数据类型，用来定义一个可变参数对象。它必须在操作可变参数时，首先使用。
- `va_start`：一个函数，用来初始化可变参数对象。它接受两个参数，第一个参数是可变参数对象，第二个参数是原始函数里面，可变参数之前的那个参数，用来为可变参数定位。
- `va_arg`：一个函数，用来取出当前那个可变参数，每次调用后，内部指针就会指向下一个可变参数。它接受两个参数，第一个是可变参数对象，第二个是当前可变参数的类型。
- `va_end`：一个函数，用来清理可变参数对象。

== 数组

=== 数组的声明方式

[source,c]
----
    int arr[3];
    int arr1[3] = {1};
    int arr2[3] = {1, 2, 3};
    int arr3[3] = {[2]=1};
----

=== 数组不可再次声明的解释

注意,数组声明后,没法再次声明;
即 int arr[3]; 声明完成后;相当于所有成员声明值为0;
不能执行 arr = {1, 2, 3};
因为 此时的 arr 是整个数组的指针;

我们将 arr当做指针变量; 则有表达式 `arr == &arr[0]`
arr(数组名称)只能当做指针变量来操作
`*arr = 10;` 即等价于 `arr[0] = 10;`
此处提现了 `variable = *(&variable)` 等式;

==== 数组的长度

====
[source,c]
----
    int scores[100];
    scores[100] = 51;<1>
    size_t arrLen = sizeof(scores) / sizeof(int);<2>
----
<1> scores[100] = 51,等价于 `*(scores+100)=51;`
强调的是 scores地址后的第100个地址的值为51;
但是此处便不会修改数组长度;数组长度只在声明时确定;对于变长数组也是成立的;

<2> 数组长度计算的表达式 `sizeof(arr)/ sizeof(arr_type);`
====

=== 二维数组与双指针变量

多维数组,我们只以二维数组来讨论;

[source,c]
----
int arr[3][3];
int arr1[3][3] = {
  {0, 1, 2},
  {3, 4, 5},
  {7, 8, 9}
};
int arr2[3][3] = {
  [1][1] = 1, [2][2] = 2
};
----

声明方式与一维数组保持一致;

但是二维数组与双指针变量,同样也保持了相同的关系;

如 `*arr[0] = &arr[0][0]`;

下面是一道挑战题目;辅助你更准确的理解指针与数组;
[source,c]
----
    int arr[3][3] = {
            {0, 1, 2},
            {3, 4, 5},
            {7, 8, 9}
    };

    **(arr + 1) = 100;
    *((*arr + 1)) = 200;
    *((*arr + 4)) = 300;

    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            printf("arr[%d,%d] address %p, value %d\n", i, j, &arr[i][j], arr[i][j]);
        }
    }
----

=== 数组的复制

数组的复制,可以将其视为指针,进行内存地址的复制;
详情查看 `内存管理` 小节

[source,c]
----
#include <string.h>

memcpy(dest, src, sizeof(dest));
----
