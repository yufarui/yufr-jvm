package indi.yufr.jvm.share.vm.utilities;

/**
 * @date: 2022/1/17 18:02
 * @author: farui.yu
 */
public class AccessFlags {

    // From jvm.h
    public static final long JVM_ACC_PUBLIC = 0x0001; /* visible to everyone */
    public static final long JVM_ACC_PRIVATE = 0x0002; /* visible only to the defining class */
    public static final long JVM_ACC_PROTECTED = 0x0004; /* visible to subclasses */
    public static final long JVM_ACC_STATIC = 0x0008; /* instance variable is static */
    public static final long JVM_ACC_FINAL = 0x0010; /* no further subclassing, overriding */
    public static final long JVM_ACC_SYNCHRONIZED = 0x0020; /* wrap method call in monitor lock */
    public static final long JVM_ACC_SUPER = 0x0020; /* funky handling of invokespecial */
    public static final long JVM_ACC_VOLATILE = 0x0040; /* can not cache in registers */
    public static final long JVM_ACC_BRIDGE = 0x0040; /* bridge method generated by compiler */
    public static final long JVM_ACC_TRANSIENT = 0x0080; /* not persistant */
    public static final long JVM_ACC_VARARGS = 0x0080; /* method declared with variable number of args */
    public static final long JVM_ACC_NATIVE = 0x0100; /* implemented in C */
    public static final long JVM_ACC_INTERFACE = 0x0200; /* class is an interface */
    public static final long JVM_ACC_ABSTRACT = 0x0400; /* no definition provided */
    public static final long JVM_ACC_STRICT = 0x0800; /* strict floating point */
    public static final long JVM_ACC_SYNTHETIC = 0x1000; /* compiler-generated class, method or field */
    public static final long JVM_ACC_ANNOTATION = 0x2000; /* annotation type */
    public static final long JVM_ACC_ENUM = 0x4000; /* field is declared as element of enum */

    // from accessFlags.hpp - hotspot internal flags

    // flags actually put in .class file
    public static final long JVM_ACC_WRITTEN_FLAGS = 0x00007FFF;

    // Method* flags
    // monitorenter/monitorexit bytecodes match
    public static final long JVM_ACC_MONITOR_MATCH = 0x10000000;
    // Method contains monitorenter/monitorexit bytecodes
    public static final long JVM_ACC_HAS_MONITOR_BYTECODES = 0x20000000;
    // Method has loops
    public static final long JVM_ACC_HAS_LOOPS = 0x40000000;
    // The loop flag has been initialized
    public static final long JVM_ACC_LOOPS_FLAG_INIT = (int) 0x80000000;
    // Queued for compilation
    public static final long JVM_ACC_QUEUED = 0x01000000;
    // TEMPORARY: currently on stack replacement compilation is not built into the
    // invocation counter machinery.  Until it is, we will keep track of methods which
    // cannot be on stack replaced in the access flags.
    public static final long JVM_ACC_NOT_OSR_COMPILABLE = 0x08000000;
    public static final long JVM_ACC_HAS_LINE_NUMBER_TABLE = 0x00100000;
    public static final long JVM_ACC_HAS_CHECKED_EXCEPTIONS = 0x00400000;
    public static final long JVM_ACC_HAS_JSRS = 0x00800000;
    // RedefineClasses() has made method obsolete
    public static final long JVM_ACC_IS_OBSOLETE = 0x00010000;

    // Klass* flags
    // True if this class has miranda methods in it's vtable
    public static final long JVM_ACC_HAS_MIRANDA_METHODS = 0x10000000;
    // True if klass has a vanilla default constructor
    public static final long JVM_ACC_HAS_VANILLA_CONSTRUCTOR = 0x20000000;
    // True if klass has a non-empty finalize() method
    public static final long JVM_ACC_HAS_FINALIZER = 0x40000000;
    // True if klass supports the Clonable interface
    public static final long JVM_ACC_IS_CLONEABLE = 0x80000000;

    // Klass* and Method* flags
    public static final long JVM_ACC_HAS_LOCAL_VARIABLE_TABLE = 0x00200000;
    // flags promoted from methods to the holding klass
    public static final long JVM_ACC_PROMOTED_FLAGS = 0x00200000;

    // field flags
    // Note: these flags must be defined in the low order 16 bits because
    // InstanceKlass only stores a ushort worth of information from the
    // AccessFlags value.
    // field access is watched by JVMTI
    public static final long JVM_ACC_FIELD_ACCESS_WATCHED = 0x00002000;
    // field modification is watched by JVMTI
    public static final long JVM_ACC_FIELD_MODIFICATION_WATCHED = 0x00008000;
    // field has generic signature
    public static final long JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE = 0x00000800;

    public AccessFlags(long flags) {
        this.flags = flags;
    }

    private long flags;

    // Java access flags
    public boolean isPublic() {
        return (flags & JVM_ACC_PUBLIC) != 0;
    }

    public boolean isPrivate() {
        return (flags & JVM_ACC_PRIVATE) != 0;
    }

    public boolean isProtected() {
        return (flags & JVM_ACC_PROTECTED) != 0;
    }

    public boolean isStatic() {
        return (flags & JVM_ACC_STATIC) != 0;
    }

    public boolean isFinal() {
        return (flags & JVM_ACC_FINAL) != 0;
    }

    public boolean isSynchronized() {
        return (flags & JVM_ACC_SYNCHRONIZED) != 0;
    }

    public boolean isSuper() {
        return (flags & JVM_ACC_SUPER) != 0;
    }

    public boolean isVolatile() {
        return (flags & JVM_ACC_VOLATILE) != 0;
    }

    public boolean isBridge() {
        return (flags & JVM_ACC_BRIDGE) != 0;
    }

    public boolean isTransient() {
        return (flags & JVM_ACC_TRANSIENT) != 0;
    }

    public boolean isVarArgs() {
        return (flags & JVM_ACC_VARARGS) != 0;
    }

    public boolean isNative() {
        return (flags & JVM_ACC_NATIVE) != 0;
    }

    public boolean isEnum() {
        return (flags & JVM_ACC_ENUM) != 0;
    }

    public boolean isAnnotation() {
        return (flags & JVM_ACC_ANNOTATION) != 0;
    }

    public boolean isInterface() {
        return (flags & JVM_ACC_INTERFACE) != 0;
    }

    public boolean isAbstract() {
        return (flags & JVM_ACC_ABSTRACT) != 0;
    }

    public boolean isStrict() {
        return (flags & JVM_ACC_STRICT) != 0;
    }

    public boolean isSynthetic() {
        return (flags & JVM_ACC_SYNTHETIC) != 0;
    }

    public long getValue() {
        return flags;
    }

    // Hotspot internal flags
    // Method* flags
    public boolean isMonitorMatching() {
        return (flags & JVM_ACC_MONITOR_MATCH) != 0;
    }

    public boolean hasMonitorBytecodes() {
        return (flags & JVM_ACC_HAS_MONITOR_BYTECODES) != 0;
    }

    public boolean hasLoops() {
        return (flags & JVM_ACC_HAS_LOOPS) != 0;
    }

    public boolean loopsFlagInit() {
        return (flags & JVM_ACC_LOOPS_FLAG_INIT) != 0;
    }

    public boolean queuedForCompilation() {
        return (flags & JVM_ACC_QUEUED) != 0;
    }

    public boolean isNotOsrCompilable() {
        return (flags & JVM_ACC_NOT_OSR_COMPILABLE) != 0;
    }

    public boolean hasLineNumberTable() {
        return (flags & JVM_ACC_HAS_LINE_NUMBER_TABLE) != 0;
    }

    public boolean hasCheckedExceptions() {
        return (flags & JVM_ACC_HAS_CHECKED_EXCEPTIONS) != 0;
    }

    public boolean hasJsrs() {
        return (flags & JVM_ACC_HAS_JSRS) != 0;
    }

    public boolean isObsolete() {
        return (flags & JVM_ACC_IS_OBSOLETE) != 0;
    }

    // Klass* flags
    public boolean hasMirandaMethods() {
        return (flags & JVM_ACC_HAS_MIRANDA_METHODS) != 0;
    }

    public boolean hasVanillaConstructor() {
        return (flags & JVM_ACC_HAS_VANILLA_CONSTRUCTOR) != 0;
    }

    public boolean hasFinalizer() {
        return (flags & JVM_ACC_HAS_FINALIZER) != 0;
    }

    public boolean isCloneable() {
        return (flags & JVM_ACC_IS_CLONEABLE) != 0;
    }

    // Klass* and Method* flags
    public boolean hasLocalVariableTable() {
        return (flags & JVM_ACC_HAS_LOCAL_VARIABLE_TABLE) != 0;
    }

    // field flags
    public boolean fieldAccessWatched() {
        return (flags & JVM_ACC_FIELD_ACCESS_WATCHED) != 0;
    }

    public boolean fieldModificationWatched() {
        return (flags & JVM_ACC_FIELD_MODIFICATION_WATCHED) != 0;
    }

    public boolean fieldHasGenericSignature() {
        return (flags & JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE) != 0;
    }

}
